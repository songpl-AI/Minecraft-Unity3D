# VoxelMeshLibrary ç§»æ¤æŒ‡å—

## ğŸ¯ 5åˆ†é’Ÿç§»æ¤åˆ°ä»»ä½•Unityé¡¹ç›®

### ğŸ“‹ å‡†å¤‡å·¥ä½œ

**éœ€è¦çš„æ–‡ä»¶ï¼ˆåªæœ‰2ä¸ªï¼ï¼‰ï¼š**
```
VoxelMeshLibrary/
â”œâ”€â”€ IVoxelData.cs          # æ¥å£å®šä¹‰ (50è¡Œ)
â””â”€â”€ VoxelMeshBuilder.cs    # æ ¸å¿ƒç®—æ³• (200è¡Œ)
```

**å¯é€‰æ–‡ä»¶ï¼š**
```
VoxelMeshLibrary/Examples/  # 3ä¸ªç¤ºä¾‹ï¼ˆå¯å‚è€ƒï¼‰
â””â”€â”€ README.md              # å®Œæ•´æ–‡æ¡£
```

---

## ğŸš€ ç§»æ¤æ­¥éª¤

### ç¬¬1æ­¥ï¼šå¤åˆ¶æ–‡ä»¶ï¼ˆ30ç§’ï¼‰

å°† `IVoxelData.cs` å’Œ `VoxelMeshBuilder.cs` å¤åˆ¶åˆ°ä½ çš„é¡¹ç›®ä¸­ï¼š

```
YourProject/
â”œâ”€â”€ Scripts/
â”‚   â””â”€â”€ VoxelMeshLibrary/
â”‚       â”œâ”€â”€ IVoxelData.cs
â”‚       â””â”€â”€ VoxelMeshBuilder.cs
```

æˆ–è€…ä»»ä½•ä½ å–œæ¬¢çš„ä½ç½®ã€‚

### ç¬¬2æ­¥ï¼šåˆ›å»ºé€‚é…å™¨ï¼ˆ2åˆ†é’Ÿï¼‰

æ ¹æ®ä½ çš„ä½“ç´ ç±»å‹ï¼Œå®ç° `IVoxelData<T>` æ¥å£ï¼š

#### æƒ…å†µAï¼šä½¿ç”¨æšä¸¾ç±»å‹

```csharp
using VoxelMeshLibrary;
using UnityEngine;

public enum MyBlockType { Air, Stone, Wood, Grass }

public class MyVoxelAdapter : IVoxelData<MyBlockType>
{
    private MyBlockType[,,] blocks;
    private Vector3Int size;

    public MyVoxelAdapter(MyBlockType[,,] blocks, int width, int height, int depth)
    {
        this.blocks = blocks;
        this.size = new Vector3Int(width, height, depth);
    }

    // 1. è·å–ä½“ç´ 
    public MyBlockType GetVoxel(int x, int y, int z)
    {
        return blocks[x, y, z];
    }

    // 2. åˆ¤æ–­æ˜¯å¦ä¸ºç©º
    public bool IsEmpty(MyBlockType voxel)
    {
        return voxel == MyBlockType.Air;  // æ ¹æ®ä½ çš„å®šä¹‰ä¿®æ”¹
    }

    // 3. è·å–UVåæ ‡
    public Vector2[] GetUVs(MyBlockType voxel, VoxelFace face)
    {
        // æ–¹å¼Aï¼šç®€å•æ˜ å°„ï¼ˆæ‰€æœ‰é¢ç›¸åŒï¼‰
        return GetSimpleUV(voxel);
        
        // æ–¹å¼Bï¼šå¤æ‚æ˜ å°„ï¼ˆä¸åŒé¢ä¸åŒçº¹ç†ï¼‰
        // return GetComplexUV(voxel, face);
    }

    // 4. è¿”å›å°ºå¯¸
    public Vector3Int Size => size;

    // è¾…åŠ©æ–¹æ³•ï¼šç®€å•UVæ˜ å°„
    Vector2[] GetSimpleUV(MyBlockType type)
    {
        float tileSize = 1f / 16f;  // å‡è®¾16x16çš„å›¾é›†
        int index = (int)type - 1;  // Air=0è·³è¿‡ï¼ŒStone=1...
        
        int x = index % 16;
        int y = index / 16;
        
        float u = x * tileSize;
        float v = y * tileSize;
        
        return new Vector2[]
        {
            new Vector2(u, v),
            new Vector2(u, v + tileSize),
            new Vector2(u + tileSize, v + tileSize),
            new Vector2(u + tileSize, v)
        };
    }
}
```

#### æƒ…å†µBï¼šä½¿ç”¨intç±»å‹

```csharp
public class IntVoxelAdapter : IVoxelData<int>
{
    private int[,,] voxels;
    private Vector3Int size;

    public IntVoxelAdapter(int[,,] voxels, Vector3Int size)
    {
        this.voxels = voxels;
        this.size = size;
    }

    public int GetVoxel(int x, int y, int z) => voxels[x, y, z];
    public bool IsEmpty(int voxel) => voxel == 0;  // 0=ç©º
    public Vector2[] GetUVs(int voxel, VoxelFace face) => GetUV(voxel);
    public Vector3Int Size => size;

    Vector2[] GetUV(int type) { /* åŒä¸Š */ }
}
```

#### æƒ…å†µCï¼šä½¿ç”¨è‡ªå®šä¹‰ç±»

```csharp
public class MyVoxel
{
    public string Type;
    public Color Color;
}

public class CustomVoxelAdapter : IVoxelData<MyVoxel>
{
    // ... å®ç°æ¥å£
    
    public bool IsEmpty(MyVoxel voxel)
    {
        return voxel == null || voxel.Type == "Air";
    }
}
```

### ç¬¬3æ­¥ï¼šç”ŸæˆMeshï¼ˆ1åˆ†é’Ÿï¼‰

```csharp
using VoxelMeshLibrary;
using UnityEngine;

public class VoxelGenerator : MonoBehaviour
{
    void GenerateVoxelModel()
    {
        // 1. å‡†å¤‡ä½“ç´ æ•°æ®
        MyBlockType[,,] blocks = new MyBlockType[10, 10, 10];
        // ... å¡«å……æ•°æ® ...

        // 2. åˆ›å»ºé€‚é…å™¨
        var adapter = new MyVoxelAdapter(blocks, 8, 8, 8);

        // 3. ç”ŸæˆMeshï¼ˆä¸€è¡Œä»£ç ï¼ï¼‰
        Mesh mesh = VoxelMeshBuilder.BuildMesh(adapter);

        // 4. åº”ç”¨åˆ°GameObject
        GameObject obj = new GameObject("VoxelModel");
        MeshFilter filter = obj.AddComponent<MeshFilter>();
        MeshRenderer renderer = obj.AddComponent<MeshRenderer>();
        MeshCollider collider = obj.AddComponent<MeshCollider>();

        filter.mesh = mesh;
        collider.sharedMesh = mesh;
        renderer.material = yourMaterial;  // ä½ çš„æè´¨
    }
}
```

### ç¬¬4æ­¥ï¼šæµ‹è¯•ï¼ˆ1åˆ†é’Ÿï¼‰

è¿è¡Œæ¸¸æˆï¼Œè°ƒç”¨ `GenerateVoxelModel()`ï¼Œåº”è¯¥èƒ½çœ‹åˆ°ç”Ÿæˆçš„æ¨¡å‹ï¼

---

## ğŸ“ å¸¸è§é›†æˆåœºæ™¯

### åœºæ™¯1ï¼šä»JSONç”Ÿæˆ

```csharp
// è§£æJSON
var jsonData = JsonUtility.FromJson<VoxelDataJson>(json);

// è½¬æ¢ä¸ºæ•°ç»„
MyBlockType[,,] blocks = new MyBlockType[size.x+2, size.y+2, size.z+2];
foreach (var voxel in jsonData.voxels)
{
    blocks[voxel.x+1, voxel.y+1, voxel.z+1] = ParseType(voxel.type);
}

// ç”ŸæˆMesh
var adapter = new MyVoxelAdapter(blocks, size.x, size.y, size.z);
Mesh mesh = VoxelMeshBuilder.BuildMesh(adapter);
```

### åœºæ™¯2ï¼šç¨‹åºåŒ–ç”Ÿæˆ

```csharp
// åˆ›å»ºä¸€ä¸ªçƒä½“
int radius = 5;
for (int x = 0; x < 10; x++)
    for (int y = 0; y < 10; y++)
        for (int z = 0; z < 10; z++)
        {
            Vector3 pos = new Vector3(x-5, y-5, z-5);
            if (pos.magnitude < radius)
                blocks[x+1, y+1, z+1] = MyBlockType.Stone;
        }

// ç”ŸæˆMesh
var adapter = new MyVoxelAdapter(blocks, 10, 10, 10);
Mesh mesh = VoxelMeshBuilder.BuildMesh(adapter);
```

### åœºæ™¯3ï¼šä»ç°æœ‰ç³»ç»Ÿè¿ç§»

å¦‚æœä½ å·²æœ‰ä½“ç´ ç³»ç»Ÿï¼š

```csharp
public class ExistingVoxelSystem
{
    public VoxelType GetBlockAt(int x, int y, int z) { ... }
    public bool IsBlockSolid(VoxelType type) { ... }
}

// åˆ›å»ºé€‚é…å™¨åŒ…è£…ç°æœ‰ç³»ç»Ÿ
public class ExistingSystemAdapter : IVoxelData<VoxelType>
{
    private ExistingVoxelSystem system;
    
    public ExistingSystemAdapter(ExistingVoxelSystem system) 
    {
        this.system = system;
    }
    
    public VoxelType GetVoxel(int x, int y, int z) 
    {
        return system.GetBlockAt(x, y, z);
    }
    
    public bool IsEmpty(VoxelType voxel) 
    {
        return !system.IsBlockSolid(voxel);
    }
    
    // ... å…¶ä»–æ–¹æ³•
}
```

---

## âš™ï¸ UVåæ ‡è¯¦è§£

UVåæ ‡æ˜¯çº¹ç†æ˜ å°„çš„å…³é”®ã€‚æ¯ä¸ªé¢éœ€è¦4ä¸ªUVåæ ‡ï¼ˆå¯¹åº”4ä¸ªé¡¶ç‚¹ï¼‰ã€‚

### ç®€å•æ˜ å°„ï¼ˆæ‰€æœ‰é¢ç›¸åŒçº¹ç†ï¼‰

```csharp
public Vector2[] GetUVs(MyBlockType voxel, VoxelFace face)
{
    // å‡è®¾16x16çš„çº¹ç†å›¾é›†
    float tileSize = 1f / 16f;
    
    // æ ¹æ®ç±»å‹è®¡ç®—åœ¨å›¾é›†ä¸­çš„ä½ç½®
    int typeIndex = (int)voxel - 1;  // Air=0è·³è¿‡
    int tileX = typeIndex % 16;
    int tileY = typeIndex / 16;
    
    float u = tileX * tileSize;
    float v = tileY * tileSize;
    
    // è¿”å›4ä¸ªé¡¶ç‚¹çš„UVï¼ˆå·¦ä¸‹ã€å·¦ä¸Šã€å³ä¸Šã€å³ä¸‹ï¼‰
    return new Vector2[]
    {
        new Vector2(u, v),                              // å·¦ä¸‹
        new Vector2(u, v + tileSize),                   // å·¦ä¸Š
        new Vector2(u + tileSize, v + tileSize),        // å³ä¸Š
        new Vector2(u + tileSize, v)                    // å³ä¸‹
    };
}
```

### å¤æ‚æ˜ å°„ï¼ˆä¸åŒé¢ä¸åŒçº¹ç†ï¼‰

```csharp
public Vector2[] GetUVs(MyBlockType voxel, VoxelFace face)
{
    // è‰æ–¹å—ï¼šé¡¶éƒ¨=è‰ï¼Œä¾§é¢=è‰æ³¥æ··åˆï¼Œåº•éƒ¨=æ³¥åœŸ
    if (voxel == MyBlockType.Grass)
    {
        switch (face)
        {
            case VoxelFace.Top:
                return GetTileUV(0, 0);  // è‰çº¹ç†åœ¨(0,0)
            case VoxelFace.Bottom:
                return GetTileUV(1, 0);  // æ³¥åœŸçº¹ç†åœ¨(1,0)
            default:
                return GetTileUV(2, 0);  // è‰ä¾§é¢åœ¨(2,0)
        }
    }
    
    // æœ¨å¤´ï¼šé¡¶åº•=å¹´è½®ï¼Œä¾§é¢=æ ‘çš®
    if (voxel == MyBlockType.Wood)
    {
        if (face == VoxelFace.Top || face == VoxelFace.Bottom)
            return GetTileUV(0, 1);  // å¹´è½®
        else
            return GetTileUV(1, 1);  // æ ‘çš®
    }
    
    // å…¶ä»–æ–¹å—ï¼šæ‰€æœ‰é¢ç›¸åŒ
    return GetTileUV((int)voxel, 0);
}

Vector2[] GetTileUV(int x, int y)
{
    float tileSize = 1f / 16f;
    float u = x * tileSize;
    float v = y * tileSize;
    
    return new Vector2[]
    {
        new Vector2(u, v),
        new Vector2(u, v + tileSize),
        new Vector2(u + tileSize, v + tileSize),
        new Vector2(u + tileSize, v)
    };
}
```

---

## ğŸ”§ æ•…éšœæ’é™¤

### é—®é¢˜1ï¼šæ¨¡å‹æ˜¯é»‘è‰²çš„

**åŸå› **ï¼šæ²¡æœ‰è®¾ç½®æè´¨æˆ–UVåæ ‡é”™è¯¯

**è§£å†³**ï¼š
```csharp
// 1. æ£€æŸ¥æè´¨æ˜¯å¦æ­£ç¡®è®¾ç½®
renderer.material = yourMaterial;
renderer.material.mainTexture = yourTexture;

// 2. æ£€æŸ¥UVåæ ‡æ˜¯å¦åœ¨[0,1]èŒƒå›´å†…
Debug.Log($"UV: {uvs[0]}, {uvs[1]}, {uvs[2]}, {uvs[3]}");
```

### é—®é¢˜2ï¼šæ¨¡å‹æ²¡æœ‰æ˜¾ç¤º

**åŸå› **ï¼š
- Meshæ˜¯ç©ºçš„ï¼ˆæ‰€æœ‰ä½“ç´ éƒ½æ˜¯ç©ºï¼‰
- ä½ç½®ä¸å¯¹ï¼ˆåœ¨ç›¸æœºåé¢ï¼‰
- ç¼©æ”¾æ˜¯0

**è§£å†³**ï¼š
```csharp
// æ£€æŸ¥Mesh
Debug.Log($"é¡¶ç‚¹æ•°: {mesh.vertexCount}, ä¸‰è§’å½¢: {mesh.triangles.Length/3}");

// æ£€æŸ¥ä½ç½®
obj.transform.position = Vector3.zero;
obj.transform.localScale = Vector3.one;
```

### é—®é¢˜3ï¼šæ•°ç»„è¶Šç•Œ

**åŸå› **ï¼šä½“ç´ æ•°ç»„å¤§å°ä¸å¯¹

**è§£å†³**ï¼š
```csharp
// ç¡®ä¿æ•°ç»„å¤§å° = å®é™…å°ºå¯¸ + 2ï¼ˆè¾¹ç•Œå±‚ï¼‰
MyBlockType[,,] blocks = new MyBlockType[width+2, height+2, depth+2];

// Sizeè¿”å›çš„æ˜¯å®é™…æ¸²æŸ“å°ºå¯¸ï¼ˆä¸å«è¾¹ç•Œå±‚ï¼‰
public Vector3Int Size => new Vector3Int(width, height, depth);
```

### é—®é¢˜4ï¼šæ€§èƒ½é—®é¢˜

**åŸå› **ï¼šä½“ç´ æ•°ç»„å¤ªå¤§

**ä¼˜åŒ–**ï¼š
```csharp
// 1. é™åˆ¶å°ºå¯¸ï¼ˆå»ºè®®ä¸è¶…è¿‡32x32x32ï¼‰
if (size.x > 32 || size.y > 32 || size.z > 32)
{
    Debug.LogWarning("ä½“ç´ æ¨¡å‹è¿‡å¤§ï¼Œå¯èƒ½å½±å“æ€§èƒ½");
}

// 2. ä½¿ç”¨å¯¹è±¡æ± ï¼ˆé¢‘ç¹ç”Ÿæˆ/é”€æ¯æ—¶ï¼‰
// 3. å¼‚æ­¥ç”Ÿæˆï¼ˆå¤§æ¨¡å‹ï¼‰
StartCoroutine(GenerateMeshAsync());
```

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 1. æ‰¹é‡ç”Ÿæˆ

```csharp
// âŒ ä¸å¥½ï¼šé€ä¸ªç”Ÿæˆ
for (int i = 0; i < 100; i++)
{
    Mesh mesh = VoxelMeshBuilder.BuildMesh(data[i]);
    Apply(mesh);
}

// âœ… å¥½ï¼šåˆ†å¸§ç”Ÿæˆ
IEnumerator GenerateMany()
{
    for (int i = 0; i < 100; i++)
    {
        Mesh mesh = VoxelMeshBuilder.BuildMesh(data[i]);
        Apply(mesh);
        
        if (i % 10 == 0)
            yield return null;  // æ¯10ä¸ªæš‚åœä¸€å¸§
    }
}
```

### 2. å¯¹è±¡æ± 

```csharp
// å¤ç”¨Meshå¯¹è±¡
Queue<Mesh> meshPool = new Queue<Mesh>();

Mesh GetMesh()
{
    if (meshPool.Count > 0)
    {
        var mesh = meshPool.Dequeue();
        mesh.Clear();
        return mesh;
    }
    return new Mesh();
}

void RecycleMesh(Mesh mesh)
{
    meshPool.Enqueue(mesh);
}
```

### 3. LODç³»ç»Ÿ

```csharp
// è¿œè·ç¦»ä½¿ç”¨ç®€åŒ–ç‰ˆæœ¬
if (distance > 50f)
    mesh = VoxelMeshBuilder.BuildMesh(simplifiedData);
else
    mesh = VoxelMeshBuilder.BuildMesh(fullData);
```

---

## âœ… æ£€æŸ¥æ¸…å•

ç§»æ¤å®Œæˆåï¼Œæ£€æŸ¥ä»¥ä¸‹é¡¹ç›®ï¼š

- [ ] å¤åˆ¶äº† `IVoxelData.cs` å’Œ `VoxelMeshBuilder.cs`
- [ ] åˆ›å»ºäº†é€‚é…å™¨ç±»å®ç° `IVoxelData<T>`
- [ ] å®ç°äº† `GetVoxel()` æ–¹æ³•
- [ ] å®ç°äº† `IsEmpty()` æ–¹æ³•ï¼ˆå®šä¹‰ä»€ä¹ˆæ˜¯"ç©º"ï¼‰
- [ ] å®ç°äº† `GetUVs()` æ–¹æ³•ï¼ˆè¿”å›4ä¸ªUVåæ ‡ï¼‰
- [ ] å®ç°äº† `Size` å±æ€§ï¼ˆè¿”å›å®é™…å°ºå¯¸ï¼‰
- [ ] æµ‹è¯•ç”Ÿæˆç®€å•æ¨¡å‹ï¼ˆå¦‚3x3x3ç«‹æ–¹ä½“ï¼‰
- [ ] æ£€æŸ¥Meshæœ‰æ­£ç¡®çš„é¡¶ç‚¹å’Œä¸‰è§’å½¢
- [ ] æ£€æŸ¥æè´¨å’Œçº¹ç†æ­£ç¡®æ˜¾ç¤º
- [ ] æµ‹è¯•ä¸åŒå°ºå¯¸çš„æ¨¡å‹

---

## ğŸ“ ä¸‹ä¸€æ­¥

ç§»æ¤å®Œæˆåï¼Œä½ å¯ä»¥ï¼š

1. **æŸ¥çœ‹ç¤ºä¾‹**ï¼š`Examples/` æ–‡ä»¶å¤¹ä¸­æœ‰3ä¸ªå®Œæ•´ç¤ºä¾‹
2. **é˜…è¯»æ–‡æ¡£**ï¼š`README.md` æœ‰è¯¦ç»†çš„APIè¯´æ˜
3. **æ‰©å±•åŠŸèƒ½**ï¼šä¿®æ”¹æ ¸å¿ƒç®—æ³•ï¼Œæ·»åŠ è‡ªå®šä¹‰ç‰¹æ€§
4. **ä¼˜åŒ–æ€§èƒ½**ï¼šå®ç°å¯¹è±¡æ± ã€LODã€å¼‚æ­¥ç”Ÿæˆç­‰

---

## ğŸ“ éœ€è¦å¸®åŠ©ï¼Ÿ

å¦‚æœé‡åˆ°é—®é¢˜ï¼š

1. æ£€æŸ¥æ§åˆ¶å°çš„é”™è¯¯ä¿¡æ¯
2. ä½¿ç”¨ `Debug.Log()` æ‰“å°ä¸­é—´å€¼
3. å‚è€ƒ `Examples/` ä¸­çš„ç¤ºä¾‹ä»£ç 
4. é˜…è¯» `README.md` çš„å¸¸è§é—®é¢˜éƒ¨åˆ†

---

**ç¥ä½ ä½¿ç”¨æ„‰å¿«ï¼** ğŸ‰

å¦‚æœè¿™ä¸ªåº“å¸®åˆ°äº†ä½ ï¼Œæ¬¢è¿åˆ†äº«ç»™å…¶ä»–å¼€å‘è€…ï¼
