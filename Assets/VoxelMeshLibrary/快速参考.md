# VoxelMeshLibrary å¿«é€Ÿå‚è€ƒå¡ç‰‡

## ğŸ“¦ æœ€å°ç§»æ¤ï¼ˆ2ä¸ªæ–‡ä»¶ï¼‰

```
å¤åˆ¶è¿™2ä¸ªæ–‡ä»¶åˆ°ä½ çš„é¡¹ç›®ï¼š
â”œâ”€â”€ IVoxelData.cs          (æ¥å£å®šä¹‰)
â””â”€â”€ VoxelMeshBuilder.cs    (æ ¸å¿ƒç®—æ³•)
```

---

## âš¡ æœ€ç®€ä½¿ç”¨ï¼ˆ3æ­¥ï¼‰

### 1. å®ç°æ¥å£

```csharp
using VoxelMeshLibrary;

public class MyAdapter : IVoxelData<int>
{
    int[,,] data;
    Vector3Int size;
    
    public int GetVoxel(int x, int y, int z) => data[x,y,z];
    public bool IsEmpty(int v) => v == 0;
    public Vector2[] GetUVs(int v, VoxelFace f) => GetMyUV(v);
    public Vector3Int Size => size;
}
```

### 2. ç”ŸæˆMesh

```csharp
Mesh mesh = VoxelMeshBuilder.BuildMesh(new MyAdapter(data, size));
```

### 3. åº”ç”¨

```csharp
meshFilter.mesh = mesh;
meshCollider.sharedMesh = mesh;
meshRenderer.material = yourMaterial;
```

---

## ğŸ¯ æ ¸å¿ƒæ¥å£

```csharp
public interface IVoxelData<T>
{
    T GetVoxel(int x, int y, int z);      // è·å–ä½“ç´ 
    bool IsEmpty(T voxel);                // æ˜¯å¦ä¸ºç©º
    Vector2[] GetUVs(T voxel, VoxelFace face);  // UVåæ ‡(4ä¸ª)
    Vector3Int Size { get; }              // å®é™…å°ºå¯¸
}
```

---

## ğŸ¨ UVåæ ‡æ¨¡æ¿

### ç®€å•æ˜ å°„ï¼ˆæ‰€æœ‰é¢ç›¸åŒï¼‰

```csharp
public Vector2[] GetUVs(int type, VoxelFace face)
{
    float tileSize = 1f / 16f;
    int x = (type - 1) % 16;
    int y = (type - 1) / 16;
    float u = x * tileSize;
    float v = y * tileSize;
    
    return new Vector2[]
    {
        new Vector2(u, v),
        new Vector2(u, v + tileSize),
        new Vector2(u + tileSize, v + tileSize),
        new Vector2(u + tileSize, v)
    };
}
```

### å¤æ‚æ˜ å°„ï¼ˆä¸åŒé¢ä¸åŒçº¹ç†ï¼‰

```csharp
public Vector2[] GetUVs(BlockType type, VoxelFace face)
{
    if (type == BlockType.Grass)
    {
        if (face == VoxelFace.Top) return GetTile(0, 0);      // è‰
        if (face == VoxelFace.Bottom) return GetTile(1, 0);   // åœŸ
        return GetTile(2, 0);  // è‰ä¾§é¢
    }
    return GetTile((int)type, 0);
}
```

---

## ğŸ“ å°ºå¯¸è§„èŒƒ

```
æ•°ç»„å¤§å° = å®é™…å°ºå¯¸ + 2ï¼ˆè¾¹ç•Œå±‚ï¼‰

å®é™…å°ºå¯¸: 8x8x8
æ•°ç»„å¤§å°: new BlockType[10, 10, 10]

ç´¢å¼•æ˜ å°„:
[0]      â†’ è¾¹ç•Œå±‚ï¼ˆå·¦/ä¸‹/å‰ï¼‰
[1-8]    â†’ å®é™…æ¸²æŸ“åŒºåŸŸ
[9]      â†’ è¾¹ç•Œå±‚ï¼ˆå³/ä¸Š/åï¼‰
```

---

## ğŸ­ é¢çš„æ–¹å‘

```
VoxelFace.Top      â†’ Y+  é¡¶é¢
VoxelFace.Bottom   â†’ Y-  åº•é¢
VoxelFace.Front    â†’ Z-  å‰é¢
VoxelFace.Back     â†’ Z+  åé¢
VoxelFace.Right    â†’ X+  å³é¢
VoxelFace.Left     â†’ X-  å·¦é¢
```

---

## ğŸ” å¸¸è§"ç©º"çš„å®šä¹‰

```csharp
// æšä¸¾ç±»å‹
public bool IsEmpty(BlockType v) => v == BlockType.Air;

// æ•´æ•°ç±»å‹
public bool IsEmpty(int v) => v == 0;

// å¯ç©ºç±»å‹
public bool IsEmpty(MyVoxel v) => v == null;

// å¤šç§é€æ˜ç±»å‹
public bool IsEmpty(MyType v) => 
    v == MyType.Air || v == MyType.Glass || v == MyType.Water;

// é˜ˆå€¼åˆ¤æ–­
public bool IsEmpty(float density) => density < 0.3f;
```

---

## ğŸ“Š æ€§èƒ½æ•°æ®

| å°ºå¯¸ | æ–¹å—æ•° | ç”Ÿæˆæ—¶é—´ | ä¼˜åŒ–ç‡ |
|-----|-------|---------|--------|
| 8Â³ | 512 | ~2ms | 87% |
| 16Â³ | 4,096 | ~10ms | 90% |
| 32Â³ | 32,768 | ~80ms | 92% |

---

## ğŸ› å¿«é€Ÿè°ƒè¯•

```csharp
// æ£€æŸ¥Mesh
Debug.Log($"é¡¶ç‚¹: {mesh.vertexCount}");
Debug.Log($"ä¸‰è§’å½¢: {mesh.triangles.Length/3}");

// æ£€æŸ¥UV
for(int i=0; i<4; i++)
    Debug.Log($"UV{i}: {mesh.uv[i]}");

// æ£€æŸ¥è¾¹ç•Œ
Debug.Log($"Bounds: {mesh.bounds}");

// å¯è§†åŒ–
mesh.RecalculateBounds();
OnDrawGizmos() {
    Gizmos.DrawWireCube(
        mesh.bounds.center, 
        mesh.bounds.size
    );
}
```

---

## âš ï¸ å¸¸è§é”™è¯¯

### é”™è¯¯1ï¼šæ•°ç»„è¶Šç•Œ
```csharp
âŒ blocks = new int[8, 8, 8];  // ç¼ºå°‘è¾¹ç•Œå±‚
âœ… blocks = new int[10, 10, 10];  // 8+2
```

### é”™è¯¯2ï¼šUVè¶Šç•Œ
```csharp
âŒ return new Vector2(10, 10);  // >1
âœ… return new Vector2(0.5f, 0.5f);  // [0,1]
```

### é”™è¯¯3ï¼šå°ºå¯¸ä¸åŒ¹é…
```csharp
âŒ Size => new Vector3Int(10, 10, 10);  // åŒ…å«è¾¹ç•Œ
âœ… Size => new Vector3Int(8, 8, 8);     // å®é™…å°ºå¯¸
```

---

## ğŸš€ ä¼˜åŒ–æŠ€å·§

### 1. é™åˆ¶å°ºå¯¸
```csharp
if (size > 32) Debug.LogWarning("å¯èƒ½å¡é¡¿");
```

### 2. åˆ†å¸§ç”Ÿæˆ
```csharp
if (i % 10 == 0) yield return null;
```

### 3. å¯¹è±¡æ± 
```csharp
Queue<Mesh> pool = new Queue<Mesh>();
```

### 4. LOD
```csharp
if (distance > 50f) mesh = simplifiedMesh;
```

---

## ğŸ“š æ–‡ä»¶ç´¢å¼•

```
VoxelMeshLibrary/
â”œâ”€â”€ README.md              # å®Œæ•´æ–‡æ¡£
â”œâ”€â”€ ç§»æ¤æŒ‡å—.md            # è¯¦ç»†ç§»æ¤æ­¥éª¤
â”œâ”€â”€ å¿«é€Ÿå‚è€ƒ.md            # æœ¬æ–‡ä»¶ï¼ˆé€ŸæŸ¥ï¼‰
â”œâ”€â”€ CHANGELOG.md           # æ›´æ–°æ—¥å¿—
â”œâ”€â”€ IVoxelData.cs          # æ¥å£å®šä¹‰ â­
â”œâ”€â”€ VoxelMeshBuilder.cs    # æ ¸å¿ƒç®—æ³• â­
â””â”€â”€ Examples/
    â”œâ”€â”€ MinecraftExample.cs    # Minecrafté£æ ¼
    â”œâ”€â”€ SimpleExample.cs       # ç®€å•æ•´æ•°
    â””â”€â”€ AdvancedExample.cs     # è‡ªå®šä¹‰ç±»
```

---

## ğŸ’¡ ä½¿ç”¨åœºæ™¯

| åœºæ™¯ | ä½“ç´ ç±»å‹ | ç¤ºä¾‹ |
|-----|---------|------|
| ä½“ç´ æ¸¸æˆ | `enum BlockType` | Minecraft |
| åŒ»å­¦å¯è§†åŒ– | `float density` | CTæ‰«æ |
| åœ°å½¢ç¼–è¾‘å™¨ | `int terrainType` | åœ°å½¢å·¥å…· |
| 3Dæ‰“å° | `bool isSolid` | æ¨¡å‹é¢„è§ˆ |
| AIç”Ÿæˆ | `string type` | JSONé©±åŠ¨ |

---

## ğŸ“ å­¦ä¹ è·¯å¾„

1. **5åˆ†é’Ÿå…¥é—¨** â†’ ç§»æ¤æŒ‡å—.md
2. **ç†è§£åŸç†** â†’ README.md
3. **æŸ¥çœ‹ç¤ºä¾‹** â†’ Examples/
4. **é€ŸæŸ¥API** â†’ æœ¬æ–‡ä»¶
5. **æ·±åº¦å®šåˆ¶** â†’ ä¿®æ”¹æºç 

---

## ğŸ“ å¸®åŠ©

**é—®é¢˜æ’æŸ¥é¡ºåºï¼š**
1. æŸ¥çœ‹Consoleé”™è¯¯ â†’ `Debug.Log()`
2. æ£€æŸ¥æœ¬æ–‡ä»¶"å¸¸è§é”™è¯¯" â†’ ä¿®å¤
3. å‚è€ƒExamples â†’ å¯¹æ¯”ä»£ç 
4. é˜…è¯»README â†’ æ·±å…¥ç†è§£

---

**ç‰ˆæœ¬**: 1.0  
**æ›´æ–°**: 2026-01-12  

**è®°ä½**: åªéœ€2ä¸ªæ–‡ä»¶ + å®ç°æ¥å£ = å®Œæˆï¼ğŸ‰
