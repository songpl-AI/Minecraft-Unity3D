# BuildMesh() 方法完整详解

> 这是将方块数据转换为3D网格的核心方法，理解它对于掌握整个渲染系统至关重要

---

## 🎯 核心目标

**将方块数据（BlockType数组）转换为Unity可渲染的3D网格（Mesh）**

```
输入：BlockType[18,64,18] 数组
  ↓
处理：面剔除 + 顶点生成 + 三角形索引
  ↓
输出：Mesh对象（包含顶点、三角形、UV、法线）
```

---

## 📊 完整流程图

```
开始 BuildMesh()
  ↓
【第1步】初始化
  ├─ 创建空Mesh对象
  ├─ 创建3个List容器（verts, tris, uvs）
  └─ 准备存储数据
  ↓
【第2步】遍历所有方块（三重循环）
  for x in [1, 17):
    for z in [1, 17):
      for y in [0, 64):
        ↓
        【第2.1步】跳过空气方块
          if blocks[x,y,z] == Air → 跳过
        ↓
        【第2.2步】计算方块位置
          blockPos = (x-1, y, z-1)
        ↓
        【第2.3步】面剔除算法
          检查6个方向：
            ├─ 顶面：上方是空气？
            ├─ 底面：下方是空气？
            ├─ 前面：前方是空气？
            ├─ 后面：后方是空气？
            ├─ 右面：右方是空气？
            └─ 左面：左方是空气？
          ↓
          如果是空气 → 生成该面的4个顶点 + UV坐标
        ↓
        【第2.4步】生成三角形索引
          为每个面生成2个三角形（6个索引）
  ↓
【第3步】组装网格
  ├─ verts.ToArray() → mesh.vertices
  ├─ tris.ToArray() → mesh.triangles
  └─ uvs.ToArray() → mesh.uv
  ↓
【第4步】计算法线
  mesh.RecalculateNormals()
  ↓
【第5步】应用网格
  ├─ MeshFilter.mesh = mesh（渲染）
  └─ MeshCollider.sharedMesh = mesh（碰撞）
  ↓
结束
```

---

## 🔍 关键概念详解

### 1. 面剔除（Face Culling）

**核心思想**：只渲染可见的面，不渲染被遮挡的面

**示例**：

```
场景1：孤立方块
  □
  → 6个面都可见 → 渲染6个面

场景2：被包围的方块
  □□□
  □■□
  □□□
  → 0个面可见 → 不渲染任何面

场景3：部分遮挡
  □
  □■
  □
  → 2个面可见（顶面、右面）→ 只渲染2个面
```

**性能提升**：
- 不剔除：16,384个方块 × 6面 = 98,304个面
- 剔除后：约2,000-5,000个面
- **节省90%+的渲染量！**

### 2. 顶点（Vertex）

**定义**：3D空间中的一个点，用Vector3表示

**一个面的顶点**：
```
顶面的4个顶点（从blockPos偏移）：

俯视图：
1 ──── 2
│     │
│     │
0 ──── 3

3D坐标：
0: (x, y+1, z)     - 左下后
1: (x, y+1, z+1)   - 左上后
2: (x+1, y+1, z+1) - 右上后
3: (x+1, y+1, z)   - 右下后
```

### 3. 三角形（Triangle）

**为什么需要三角形？**
- Unity渲染的是三角形，不是四边形
- 一个四边形必须分割成2个三角形

**分割方式**：
```
四边形：
1 ──── 2
│  ╱  │
│ ╱   │
0 ──── 3

分割成：
三角形1：0 → 1 → 2
三角形2：0 → 2 → 3
```

### 4. 索引（Index）

**定义**：指向顶点数组的索引号

**为什么用索引？**
- 共享顶点：相邻面可以共享顶点
- 节省内存：避免重复存储相同顶点
- 提高性能：GPU可以缓存顶点数据

**示例**：
```
顶点数组：
  [0] = (0, 1, 0)
  [1] = (0, 1, 1)
  [2] = (1, 1, 1)
  [3] = (1, 1, 0)

三角形索引：
  三角形1：[0, 1, 2]  → 使用顶点0,1,2
  三角形2：[0, 2, 3]  → 使用顶点0,2,3
```

### 5. UV坐标

**定义**：纹理坐标，范围[0,1]，用于从纹理图集中采样

**作用**：
- 告诉GPU如何将纹理映射到模型上
- 每个顶点对应一个UV坐标

**示例**：
```
顶面的4个UV坐标：
  (0, 0) ──── (1, 0)
    │           │
    │           │
  (0, 1) ──── (1, 1)

对应纹理图集中的位置
```

### 6. 法线（Normal）

**定义**：垂直于面的向量，用于光照计算

**作用**：
- 光照系统需要知道面的朝向
- 朝向光源的面更亮
- 创造3D立体感

**计算**：
- Unity自动计算
- 基于相邻三角形平均

---

## 🎮 完整示例

### 示例：生成一个方块的网格

**输入**：位置(5, 20, 8)，类型Dirt，周围情况：
- 上方：Air（可见）
- 下方：Stone（被遮挡）
- 前方：Air（可见）
- 后方：Dirt（被遮挡）
- 右方：Air（可见）
- 左方：Dirt（被遮挡）

**处理过程**：

```
1. 计算位置
   blockPos = (4, 20, 7)

2. 检查6个方向
   - 顶面：上方是Air → 生成顶面 ✅
   - 底面：下方是Stone → 不生成 ❌
   - 前面：前方是Air → 生成前面 ✅
   - 后面：后方是Dirt → 不生成 ❌
   - 右面：右方是Air → 生成右面 ✅
   - 左面：左方是Dirt → 不生成 ❌
   
   结果：生成3个面

3. 添加顶点（每个面4个顶点，共12个）
   顶面：
     verts[100] = (4, 21, 7)
     verts[101] = (4, 21, 8)
     verts[102] = (5, 21, 8)
     verts[103] = (5, 21, 7)
   
   前面：
     verts[104] = (4, 20, 7)
     verts[105] = (4, 21, 7)
     verts[106] = (5, 21, 7)
     verts[107] = (5, 20, 7)
   
   右面：
     verts[108] = (5, 20, 7)
     verts[109] = (5, 21, 7)
     verts[110] = (5, 21, 8)
     verts[111] = (5, 20, 8)

4. 添加UV坐标（12个，对应12个顶点）
   顶面：使用Dirt的topPos纹理
   前面：使用Dirt的sidePos纹理
   右面：使用Dirt的sidePos纹理

5. 生成三角形索引（每个面2个三角形，共6个三角形）
   顶面：
     tris[200] = 100, 101, 102  （三角形1）
     tris[201] = 100, 102, 103  （三角形2）
   
   前面：
     tris[202] = 104, 105, 106
     tris[203] = 104, 106, 107
   
   右面：
     tris[204] = 108, 109, 110
     tris[205] = 108, 110, 111

6. 组装成Mesh
   mesh.vertices = [所有顶点]
   mesh.triangles = [所有索引]
   mesh.uv = [所有UV坐标]

7. 计算法线
   mesh.RecalculateNormals()

8. 应用网格
   MeshFilter.mesh = mesh
   MeshCollider.sharedMesh = mesh
```

---

## 📈 性能分析

### 时间复杂度

```
O(n) 其中 n = 方块数量
- 遍历：16 × 16 × 64 = 16,384次
- 每个方块：最多6次检查（6个方向）
- 总操作：约100,000次（非常快）
```

### 空间复杂度

```
O(f) 其中 f = 可见面数
- 顶点：f × 4
- 索引：f × 6
- UV：f × 4
- 总内存：约200-500KB（很小）
```

### 实际性能

```
典型区块（50%填充率）：
- 方块数：约8,000个
- 可见面：约2,000个
- 顶点数：8,000个
- 三角形数：4,000个
- 生成时间：5-10毫秒 ✅
- 内存占用：约200KB ✅
```

---

## 🔧 优化技巧

### 1. 面剔除
- **效果**：减少90%+的渲染量
- **实现**：检查6个方向的邻接方块

### 2. 共享顶点
- **效果**：减少内存占用
- **实现**：相邻面共享顶点（通过索引）

### 3. 单一网格
- **效果**：减少Draw Call
- **实现**：整个区块用一个Mesh

### 4. 延迟生成
- **效果**：避免卡顿
- **实现**：只在数据改变时调用

---

## 💡 关键理解点

### 1. 为什么需要这个方法？

Unity无法直接渲染"方块数据"，必须转换为"网格数据"。

### 2. 面剔除为什么重要？

不剔除：98,304个面
剔除后：2,000个面
**性能提升：50倍！**

### 3. 索引系统如何工作？

通过索引指向顶点，实现顶点共享，节省内存。

### 4. 为什么用逆时针顺序？

Unity使用右手定则，逆时针 → 法线朝外 → 正面可见。

---

## 🎓 学习建议

1. **理解面剔除**：这是最重要的优化
2. **理解索引系统**：这是3D渲染的基础
3. **理解UV映射**：这是纹理应用的关键
4. **实践调试**：在Unity中查看生成的网格

---

**这就是BuildMesh()的完整逻辑！** 🎮✨
