# 体素模型生成器使用说明

## 概述

`VoxelModelGenerator.cs` 是一个可以从JSON数据生成3D体素模型的工具脚本。它可以：

- ✅ 解析JSON格式的体素数据（可由LLM生成）
- ✅ 使用现有的方块类型和纹理系统
- ✅ 利用mesh合并技术优化性能
- ✅ 自动检测地面并放置模型
- ✅ 支持在玩家前方生成模型

## 快速开始

### 1. 设置脚本

1. 在Unity场景中创建一个空GameObject（命名为 "VoxelModelGenerator"）
2. 将 `VoxelModelGenerator.cs` 脚本拖拽到该GameObject上
3. 在Inspector面板中配置参数：
   - **JSON Data**: 粘贴体素模型的JSON数据
   - **Generate On Start**: 勾选后会在游戏开始时自动生成
   - **Spawn Distance From Player**: 设置距离玩家的距离（默认5米）
   - **Snap To Ground**: 勾选后会自动放置在地面上

### 2. 测试生成

有两种方式测试：

#### 方式A：在Inspector中使用测试数据

1. 打开脚本文件 `VoxelModelGenerator.cs`
2. 复制 `GetTestDogJson()` 方法返回的JSON数据
3. 粘贴到Inspector中的 "Json Data" 字段
4. 运行游戏，脚本会自动在玩家前方生成一只简单的狗模型

#### 方式B：按键触发生成

1. 运行游戏后
2. 按下键盘 **G键**
3. 会在玩家当前位置前方生成模型

## JSON数据格式

### 基本格式

```json
{
  "name": "模型名称",
  "size": {
    "x": 宽度,
    "y": 高度,
    "z": 深度
  },
  "voxels": [
    {"x": 0, "y": 0, "z": 0, "blockType": "Dirt"},
    {"x": 1, "y": 0, "z": 0, "blockType": "Stone"},
    ...
  ]
}
```

### 字段说明

- **name**: 模型的名称（会作为GameObject的名称）
- **size**: 模型的尺寸
  - `x`: 宽度（X轴）
  - `y`: 高度（Y轴）
  - `z`: 深度（Z轴）
- **voxels**: 体素数组，每个体素包含：
  - `x`, `y`, `z`: 体素在模型内的坐标（从0开始）
  - `blockType`: 方块类型（见下方支持的类型）

### 支持的方块类型

| 类型名称 | 说明 | 外观 |
|---------|------|------|
| `Grass` | 草方块 | 顶部绿色，侧面草泥混合，底部泥土色 |
| `Dirt` | 泥土方块 | 棕色 |
| `Stone` | 石头方块 | 灰色 |
| `Trunk` | 树干方块 | 侧面树皮纹理，顶底年轮纹理 |
| `Leaves` | 树叶方块 | 绿色半透明 |

### 示例：简单的狗模型

```json
{
  "name": "SimpleDog",
  "size": {"x": 8, "y": 6, "z": 12},
  "voxels": [
    // 四条腿（使用Stone作为脚）
    {"x": 2, "y": 0, "z": 2, "blockType": "Stone"},
    {"x": 5, "y": 0, "z": 2, "blockType": "Stone"},
    {"x": 2, "y": 0, "z": 9, "blockType": "Stone"},
    {"x": 5, "y": 0, "z": 9, "blockType": "Stone"},
    
    // 腿部（使用Dirt作为身体）
    {"x": 2, "y": 1, "z": 2, "blockType": "Dirt"},
    {"x": 5, "y": 1, "z": 2, "blockType": "Dirt"},
    {"x": 2, "y": 1, "z": 9, "blockType": "Dirt"},
    {"x": 5, "y": 1, "z": 9, "blockType": "Dirt"},
    
    // 身体部分（矩形身体）
    {"x": 2, "y": 2, "z": 3, "blockType": "Dirt"},
    {"x": 3, "y": 2, "z": 3, "blockType": "Dirt"},
    // ... 更多体素
    
    // 头部（使用Leaves作为耳朵，Stone作为眼睛）
    {"x": 3, "y": 3, "z": 10, "blockType": "Dirt"},
    {"x": 4, "y": 3, "z": 10, "blockType": "Dirt"},
    {"x": 3, "y": 4, "z": 10, "blockType": "Stone"},
    {"x": 4, "y": 4, "z": 10, "blockType": "Stone"}
  ]
}
```

## 工作原理

### 1. JSON解析
```
JSON字符串 → JsonUtility.FromJson() → VoxelData对象
```

### 2. 数据转换
```
VoxelData → BlockType[,,] 三维数组
```
- 创建比模型尺寸大2的数组（用于边界检测）
- 将JSON中的体素填充到数组中
- 未填充的位置默认为Air（空气）

### 3. Mesh生成
使用与 `TerrainChunk` 相同的算法：
- **面剔除**: 只渲染暴露在空气中的面
- **顶点共享**: 优化内存和性能
- **UV映射**: 使用现有的纹理图集

### 4. 位置计算
```
玩家位置 + 前方向量 × 距离 = 生成位置
↓
射线检测地面高度
↓
最终位置
```

### 5. 对象创建
```
GameObject
├─ MeshFilter (存储mesh数据)
├─ MeshRenderer (渲染mesh，使用地形材质)
└─ MeshCollider (物理碰撞)
```

## 高级用法

### 代码调用

```csharp
// 获取生成器组件
VoxelModelGenerator generator = GetComponent<VoxelModelGenerator>();

// 设置JSON数据
generator.jsonData = yourJsonString;

// 生成模型
generator.GenerateAndSpawnModel();
```

### 自定义位置

如果需要在指定位置生成（而不是玩家前方），可以修改代码：

```csharp
// 在CalculateSpawnPosition方法中
Vector3 position = new Vector3(10, 0, 10); // 你的自定义位置
```

### 与LLM集成

当从LLM获取JSON数据时：

```csharp
// 假设从API获取了JSON字符串
string llmGeneratedJson = GetFromLLMAPI("生成一只狗");

// 设置到生成器
generator.jsonData = llmGeneratedJson;
generator.GenerateAndSpawnModel();
```

## 性能考虑

### Mesh合并优化

脚本使用了与TerrainChunk相同的mesh合并技术：
- **面剔除**: 只渲染可见的面，节省90%+顶点
- **单一Mesh**: 整个模型合并为一个mesh，减少Draw Call
- **共享顶点**: 通过索引共享顶点，节省内存

### 适合的模型尺寸

| 尺寸 | 体素数量 | 性能 |
|-----|---------|------|
| 小型 (8x8x8) | ~512 | ✅ 优秀 |
| 中型 (16x16x16) | ~4,096 | ✅ 良好 |
| 大型 (32x32x32) | ~32,768 | ⚠️ 可能卡顿 |

建议：
- 单个模型不超过 20x20x20
- 如需更大模型，考虑分块生成

## 调试技巧

### 查看生成日志

生成成功时会输出：
```
成功生成体素模型：SimpleDog，位置：(10.5, 32.0, 15.3)
```

### 常见问题

**问题1: 模型没有出现**
- 检查JSON格式是否正确
- 确认 `generateOnStart` 已勾选
- 查看Console是否有错误信息

**问题2: 模型没有纹理**
- 确保场景中有TerrainChunk对象（用于获取材质）
- 检查材质是否正确设置

**问题3: 模型位置不对**
- 检查 `player` 引用是否正确
- 调整 `spawnDistanceFromPlayer` 参数
- 检查地面检测是否正常工作

## 扩展建议

### 1. 添加新的方块类型

在 `Block.cs` 中添加新类型后，更新 `ParseBlockType()` 方法：

```csharp
case "newtype": return BlockType.NewType;
```

### 2. 支持更多JSON格式

可以修改 `VoxelData` 类来支持其他格式，例如：

```json
{
  "blocks": [
    [["Dirt", "Stone"], ["Air", "Grass"]],
    [["Dirt", "Dirt"], ["Air", "Air"]]
  ]
}
```

### 3. 动画支持

可以扩展脚本，支持体素模型的简单动画：
- 旋转
- 移动
- 缩放

## 总结

这个工具让你可以轻松地从JSON数据创建3D体素模型，非常适合与LLM集成，实现"用自然语言生成3D模型"的功能。

核心优势：
- 🚀 利用现有的方块系统，无需额外资源
- 🎨 自动纹理映射，外观统一
- ⚡ 高效的mesh合并，性能优秀
- 🎯 简单易用，JSON格式清晰

试试按G键，看看效果吧！
