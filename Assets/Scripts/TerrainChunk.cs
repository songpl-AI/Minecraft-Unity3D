using System.Collections;
using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// 地形区块类 - 管理单个区块的方块数据和网格生成
/// 
/// 【设计原理】
/// - 区块系统：将无限世界划分为16x64x16的小块，便于管理和优化
/// - 动态网格生成：根据方块数据实时构建3D网格
/// - 贪婪网格算法：只渲染暴露在空气中的面，大幅减少顶点数
/// - 邻接检测：多2层边界数据用于检测相邻区块的方块
/// 
/// 【核心算法】
/// 1. 遍历所有非空气方块
/// 2. 检查6个方向的邻接方块
/// 3. 如果邻接方块是空气，生成该方向的面
/// 4. 应用对应的纹理UV坐标
/// 5. 构建三角形索引
/// 
/// 【性能优化】
/// - 面剔除：内部不可见的面不生成（节省90%+顶点）
/// - 单一网格：一个区块只用一个Mesh，减少Draw Call
/// - 共享顶点：相邻三角形共享顶点（通过索引）
/// 
/// 【数据结构】
/// - blocks[18,64,18]：比实际尺寸多2层，用于边界检测
///   * [0]和[17]是边界层，存储相邻区块的方块
///   * [1-16]是实际渲染的方块
/// 
/// 【架构位置】
/// TerrainGenerator(生成数据) → TerrainChunk(构建网格) → MeshFilter/MeshCollider(渲染/碰撞)
/// </summary>
public class TerrainChunk : MonoBehaviour
{
    // 【区块尺寸常量】
    // 
    // 【为什么是16x64x16？】
    // 
    // 1. 宽度/深度 = 16 的原因：
    //    ✅ 二进制优势：16 = 2^4，位运算优化（x/16 = x>>4，x%16 = x&15）
    //    ✅ 内存友好：16x16x64 = 16,384个方块，约64KB内存（每个方块1字节）
    //    ✅ 网格大小：单个区块网格不会过大，BuildMesh()耗时可控（<10ms）
    //    ✅ 加载粒度：16米足够小，玩家移动时能平滑加载新区块
    //    ✅ 历史标准：Minecraft使用16x16，成为行业标准，工具和资源都围绕这个尺寸
    //    ✅ 视野平衡：16米约等于玩家视野的1/5，既不会太频繁加载，也不会看到边界
    // 
    // 2. 高度 = 64 的原因：
    //    ✅ 足够高度：64格（假设1格=1米）足够覆盖大部分地形变化
    //    ✅ 内存平衡：如果太高（如256），内存占用会过大
    //    ✅ 渲染效率：64格高度在面剔除后，实际渲染面数可控
    //    ✅ 游戏性：64米高度足够建造大型建筑，又不会让世界过于空旷
    //    ⚠️  注意：Minecraft原版是256格高，这里用64是简化版
    // 
    // 3. 尺寸权衡表：
    //    尺寸       | 方块数  | 内存(1字节/方块) | BuildMesh耗时 | 加载频率
    //    ----------|---------|-----------------|--------------|----------
    //    8x32x8    | 2,048   | 2KB             | ~1ms         | 频繁
    //    16x64x16  | 16,384  | 64KB            | ~5-10ms      | 适中 ✅
    //    32x128x32 | 131,072 | 512KB           | ~50-100ms    | 稀少
    //    64x256x64 | 1,048,576| 4MB             | ~500ms+      | 很少（卡顿）
    // 
    // 4. 为什么不是其他数字？
    //    ❌ 8x8x8：太小，加载太频繁，边界明显
    //    ❌ 32x32x32：网格太大，BuildMesh会卡顿
    //    ❌ 非2的幂次（如15、17）：无法用位运算优化，性能略差
    //    ✅ 16x64x16：在性能、内存、体验之间的最佳平衡点
    // 
    // 5. 实际影响：
    //    - 玩家移动速度6m/s → 每2.7秒进入新区块 → 加载频率适中
    //    - 11x11区块视野 = 176x176米可见范围 = 合理
    //    - 单个区块网格约5000-15000个顶点（面剔除后）→ 渲染流畅
    // 
    // 6. 可调整性：
    //    如果您的游戏需要：
    //    - 更精细的地形 → 减小到8x32x8（但会增加加载频率）
    //    - 更大的建筑空间 → 增加到32x128x32（但会降低性能）
    //    - 保持当前平衡 → 16x64x16 是最佳选择 ✅
    public const int chunkWidth = 16;   // 区块宽度（X和Z方向）
    public const int chunkHeight = 64;  // 区块高度（Y方向）

    // 【方块数据数组】
    // 三维数组：[X, Y, Z]
    // 大小[18,64,18]：比实际尺寸(16x64x16)多2层
    // 
    // 为什么多2层？
    // - 索引[0]和[17]存储相邻区块的边界方块
    // - 用于判断边缘方块是否需要渲染面
    // - 避免区块边界出现裂缝
    // 
    // 示例：blocks[1,10,1]是实际的第一个方块
    //      blocks[0,10,1]是左侧相邻区块的最后一个方块
    public BlockType[,,] blocks = new BlockType[chunkWidth + 2, chunkHeight, chunkWidth + 2];

    void Start()
    {
        // 无需初始化，由TerrainGenerator填充数据
    }

    /// <summary>
    /// 【核心方法】根据方块数据构建3D网格
    /// 
    /// 【为什么需要这个方法？】
    /// Unity无法直接渲染"方块数据"（BlockType数组）
    /// 必须将方块数据转换为Unity能理解的"网格"（Mesh）
    /// 
    /// 【转换过程】：
    /// 方块数据（BlockType[,,]） → 3D网格（Mesh）
    ///   ↓
    /// 每个方块 → 6个面（可能） → 每个面4个顶点 → 每个面2个三角形
    /// 
    /// 【核心算法：面剔除（Face Culling）】
    /// 只渲染"暴露在空气中"的面，内部不可见的面不渲染
    /// 
    /// 示例：
    ///   □□□  → 只渲染外表面（6个面）
    ///   □■□  → 中间的方块只渲染顶面（其他5个面被遮挡）
    ///   □□□
    /// 
    /// 性能提升：节省90%+的顶点和三角形！
    /// 
    /// 【完整流程】：
    /// 1. 遍历所有方块位置（三重循环）
    /// 2. 跳过空气方块（不渲染）
    /// 3. 对于实体方块，检查6个方向
    /// 4. 如果某方向是空气 → 生成该面的4个顶点
    /// 5. 为每个面添加UV坐标（纹理映射）
    /// 6. 为每个面生成2个三角形（6个索引）
    /// 7. 组装成Mesh对象
    /// 8. 应用到MeshFilter和MeshCollider
    /// 
    /// 【性能考虑】：
    /// - 使用List动态添加，避免预分配过大数组
    /// - 只在数据改变时调用（放置/破坏方块）
    /// - 单次调用可能需要几毫秒（大区块）
    /// - 面剔除大幅减少顶点数（从16,384*6面 → 约2,000-5,000个面）
    /// </summary>
    public void BuildMesh()
    {
        // ========== 【第1步：初始化】==========
        // 
        // 【创建空的Mesh对象】
        // Mesh是Unity中表示3D模型的数据结构
        // 包含：顶点位置、三角形索引、UV坐标、法线等
        Mesh mesh = new Mesh();

        // 【创建数据容器】
        // 
        // 为什么用List而不是数组？
        // - 数组需要预知大小（16x64x16 = 16,384个方块）
        // - 但实际渲染的面数未知（取决于面剔除）
        // - List可以动态增长，更灵活
        // 
        // verts：存储所有顶点的3D位置（Vector3）
        //   每个面有4个顶点，但相邻面共享顶点
        //   示例：一个方块有6个面，最多24个顶点
        // 
        // tris：存储三角形索引（int数组）
        //   每个三角形由3个顶点索引组成
        //   每个面 = 2个三角形 = 6个索引
        //   示例：10个面 = 20个三角形 = 60个索引
        // 
        // uvs：存储纹理坐标（Vector2数组）
        //   每个顶点对应一个UV坐标
        //   UV坐标范围[0,1]，用于从纹理图集中采样
        //   示例：4个顶点 = 4个UV坐标
        // 
        List<Vector3> verts = new List<Vector3>();  // 顶点位置列表
        List<int> tris = new List<int>();           // 三角形索引列表（每3个索引定义一个三角形）
        List<Vector2> uvs = new List<Vector2>();    // UV纹理坐标列表

        // ========== 【第2步：遍历所有方块】==========
        // 
        // 【三重循环】遍历区块内所有方块位置
        // 
        // 为什么x和z从1开始？
        // - blocks数组大小是[18,64,18]（包含边界层）
        // - [0]和[17]是边界层，存储相邻区块的方块（用于面剔除判断）
        // - [1-16]是实际渲染的方块
        // 
        // 为什么y从0开始？
        // - Y方向没有边界层（高度是固定的64）
        // - 从0到63，共64层
        // 
        // 遍历顺序：从下到上，从前到后，从左到右
        //   for y in [0, 64):      // 从底部到顶部
        //     for z in [1, 17):    // 从前到后
        //       for x in [1, 17):  // 从左到右
        // 
        // 总循环次数：16 * 16 * 64 = 16,384次
        for(int x = 1; x < chunkWidth + 1; x++)
            for(int z = 1; z < chunkWidth + 1; z++)
                for(int y = 0; y < chunkHeight; y++)
                {
                    // ========== 【第2.1步：跳过空气方块】==========
                    // 
                    // 【为什么跳过空气？】
                    // - 空气方块不渲染（没有模型）
                    // - 节省计算：16,384个方块中可能只有1/3是实体
                    // - 性能提升：减少5,000+次不必要的检查
                    // 
                    // 【示例】：
                    //   位置(5, 30, 5)是空气 → 跳过，不处理
                    //   位置(5, 20, 5)是泥土 → 继续处理
                    if(blocks[x, y, z] != BlockType.Air)
                    {
                        // ========== 【第2.2步：计算方块位置】==========
                        // 
                        // 【坐标转换】
                        // 数组索引 → 世界坐标
                        // 
                        // 为什么减1？
                        // - 数组索引从1开始（跳过边界层[0]）
                        // - 但世界坐标从0开始
                        // 
                        // 示例：
                        //   数组索引[1, 10, 1] → 世界坐标(0, 10, 0)
                        //   数组索引[5, 20, 8] → 世界坐标(4, 20, 7)
                        //   数组索引[16, 30, 16] → 世界坐标(15, 30, 15)
                        // 
                        // blockPos是方块的"左下后"角（最小角）
                        // 方块的8个顶点都是基于这个位置偏移
                        Vector3 blockPos = new Vector3(x - 1, y, z - 1);
                        
                        // 【记录面数】
                        // 用于后续计算三角形索引
                        // 每个方块最多6个面，但通常只有2-4个面可见
                        int numFaces = 0;
                        
                        // ========== 【第2.3步：面剔除算法 - 检查6个方向】==========
                        // 
                        // 【核心思想：只渲染可见的面】
                        // 
                        // 一个方块有6个面：
                        //   - 顶面（Top）：Y+方向
                        //   - 底面（Bottom）：Y-方向
                        //   - 前面（Front）：Z-方向
                        //   - 后面（Back）：Z+方向
                        //   - 右面（Right）：X+方向
                        //   - 左面（Left）：X-方向
                        // 
                        // 【判断逻辑】：
                        //   如果某个方向的邻接方块是空气 → 这个面可见 → 需要渲染
                        //   如果某个方向的邻接方块是实体 → 这个面被遮挡 → 不渲染
                        // 
                        // 【可视化示例】：
                        // 
                        // 场景1：孤立的方块（6个面都可见）
                        //   □
                        //   → 渲染6个面
                        // 
                        // 场景2：被包围的方块（0个面可见）
                        //   □□□
                        //   □■□  → 中间的方块不渲染任何面
                        //   □□□
                        // 
                        // 场景3：部分遮挡（2-4个面可见）
                        //   □
                        //   □■  → 中间的方块渲染顶面和右面
                        //   □
                        // 
                        // ========== 【顶面检查】==========
                        // 
                        // 【条件1】y < chunkHeight - 1
                        //   含义：不在区块顶部（顶部方块的上方没有方块，一定可见）
                        //   如果y=63（顶部），上方没有方块，顶面一定可见
                        // 
                        // 【条件2】blocks[x, y + 1, z] == BlockType.Air
                        //   含义：上方是空气 → 顶面可见
                        // 
                        // 【两个条件的关系】：
                        //   - 如果y=63：顶面一定可见（不需要检查上方）
                        //   - 如果y<63：需要检查上方是否是空气
                        // 
                        // 【顶点添加】：
                        //   一个面由4个顶点组成，形成一个四边形（Quad）
                        // 
                        //   顶面的4个顶点（从blockPos偏移）：
                        // 
                        //   俯视图（从上方看）：
                        //   1 ──── 2
                        //   │     │
                        //   │     │
                        //   0 ──── 3
                        // 
                        //   顶点顺序（逆时针，从Unity相机看）：
                        //   0: (0, 1, 0) - 左下后
                        //   1: (0, 1, 1) - 左上后
                        //   2: (1, 1, 1) - 右上后
                        //   3: (1, 1, 0) - 右下后
                        // 
                        // 【为什么逆时针？】
                        //   Unity使用右手定则判断面的朝向
                        //   逆时针 → 法线朝外（向上）→ 正面可见
                        //   顺时针 → 法线朝内（向下）→ 背面被剔除
                        // 
                        if(y < chunkHeight - 1 && blocks[x, y + 1, z] == BlockType.Air)
                        {
                            // 添加4个顶点（逆时针顺序）
                            verts.Add(blockPos + new Vector3(0, 1, 0)); // 顶点0：左下后
                            verts.Add(blockPos + new Vector3(0, 1, 1)); // 顶点1：左上后
                            verts.Add(blockPos + new Vector3(1, 1, 1)); // 顶点2：右上后
                            verts.Add(blockPos + new Vector3(1, 1, 0)); // 顶点3：右下后
                            numFaces++;  // 记录这个方块多了一个面

                            // 【添加UV坐标】
                            // 从Block字典获取该方块类型的顶面纹理坐标
                            // 例如：草方块的顶面使用Grass纹理
                            // 返回4个Vector2，对应4个顶点的UV坐标
                            uvs.AddRange(Block.blocks[blocks[x, y, z]].topPos.GetUVs());
                        }

                        // 【底面】检查下方是否有方块
                        if(y > 0 && blocks[x, y - 1, z] == BlockType.Air)
                        {
                            // 底面顶点顺序与顶面相反（法线向下）
                            verts.Add(blockPos + new Vector3(0, 0, 0));
                            verts.Add(blockPos + new Vector3(1, 0, 0));
                            verts.Add(blockPos + new Vector3(1, 0, 1));
                            verts.Add(blockPos + new Vector3(0, 0, 1));
                            numFaces++;

                            uvs.AddRange(Block.blocks[blocks[x, y, z]].bottomPos.GetUVs());
                        }

                        // 【前面】Z负方向（朝向相机初始方向）
                        if(blocks[x, y, z - 1] == BlockType.Air)
                        {
                            verts.Add(blockPos + new Vector3(0, 0, 0));
                            verts.Add(blockPos + new Vector3(0, 1, 0));
                            verts.Add(blockPos + new Vector3(1, 1, 0));
                            verts.Add(blockPos + new Vector3(1, 0, 0));
                            numFaces++;

                            uvs.AddRange(Block.blocks[blocks[x, y, z]].sidePos.GetUVs());
                        }

                        // 【右面】X正方向
                        if(blocks[x + 1, y, z] == BlockType.Air)
                        {
                            verts.Add(blockPos + new Vector3(1, 0, 0));
                            verts.Add(blockPos + new Vector3(1, 1, 0));
                            verts.Add(blockPos + new Vector3(1, 1, 1));
                            verts.Add(blockPos + new Vector3(1, 0, 1));
                            numFaces++;

                            uvs.AddRange(Block.blocks[blocks[x, y, z]].sidePos.GetUVs());
                        }

                        // 【后面】Z正方向
                        if(blocks[x, y, z + 1] == BlockType.Air)
                        {
                            verts.Add(blockPos + new Vector3(1, 0, 1));
                            verts.Add(blockPos + new Vector3(1, 1, 1));
                            verts.Add(blockPos + new Vector3(0, 1, 1));
                            verts.Add(blockPos + new Vector3(0, 0, 1));
                            numFaces++;

                            uvs.AddRange(Block.blocks[blocks[x, y, z]].sidePos.GetUVs());
                        }

                        // 【左面】X负方向
                        if(blocks[x - 1, y, z] == BlockType.Air)
                        {
                            verts.Add(blockPos + new Vector3(0, 0, 1));
                            verts.Add(blockPos + new Vector3(0, 1, 1));
                            verts.Add(blockPos + new Vector3(0, 1, 0));
                            verts.Add(blockPos + new Vector3(0, 0, 0));
                            numFaces++;

                            uvs.AddRange(Block.blocks[blocks[x, y, z]].sidePos.GetUVs());
                        }

                        // ========== 【第2.4步：生成三角形索引】==========
                        // 
                        // 【为什么需要三角形索引？】
                        // Unity渲染的是三角形，不是四边形
                        // 一个四边形（Quad）必须分割成2个三角形（Triangle）
                        // 
                        // 【四边形分割方式】：
                        // 
                        //   顶点布局：
                        //   1 ──── 2
                        //   │  ╱  │
                        //   │ ╱   │
                        //   0 ──── 3
                        // 
                        //   分割成2个三角形：
                        //   三角形1：0 → 1 → 2（左下→左上→右上）
                        //   三角形2：0 → 2 → 3（左下→右上→右下）
                        // 
                        //   为什么这样分割？
                        //   - 对角线分割（0-2）是最简单的方式
                        //   - 两个三角形共享边（0-2）
                        //   - 保证所有顶点都在同一平面上
                        // 
                        // 【索引计算】：
                        // 
                        // 问题：如何找到这个方块所有面的顶点在verts列表中的位置？
                        // 
                        // 解决方案：
                        //   - 这个方块的所有面是连续添加的
                        //   - 每个面4个顶点
                        //   - 如果这个方块有3个面，就有12个顶点
                        //   - 第一个顶点的索引 = 总顶点数 - 这个方块的顶点数
                        // 
                        // 【计算示例】：
                        // 
                        // 假设当前状态：
                        //   - verts列表已有100个顶点（索引0-99）
                        //   - 当前方块有3个面（顶面、前面、右面）
                        //   - 每个面4个顶点，共12个顶点
                        // 
                        // 添加顶点后：
                        //   - verts列表有112个顶点（索引0-111）
                        //   - 当前方块的顶点索引：100-111
                        //   - 第一个顶点索引：100 = 112 - 12 = verts.Count - 4*3
                        // 
                        // 公式：
                        //   tl = verts.Count - 4 * numFaces
                        // 
                        //   其中：
                        //   - verts.Count：当前总顶点数
                        //   - 4 * numFaces：这个方块的顶点数（每个面4个顶点）
                        //   - tl：这个方块第一个顶点的索引（Top Left的缩写，但实际是第一个）
                        // 
                        int tl = verts.Count - 4 * numFaces;
                        
                        // 【为每个面生成三角形】
                        // 
                        // 遍历这个方块的所有面（numFaces个）
                        // 每个面生成2个三角形（6个索引）
                        // 
                        // 索引计算：
                        //   第0个面的顶点：tl + 0*4, tl+1, tl+2, tl+3
                        //   第1个面的顶点：tl + 1*4, tl+5, tl+6, tl+7
                        //   第2个面的顶点：tl + 2*4, tl+9, tl+10, tl+11
                        //   ...
                        // 
                        // 通用公式：
                        //   第i个面的4个顶点：
                        //     tl + i*4 + 0  （顶点0）
                        //     tl + i*4 + 1  （顶点1）
                        //     tl + i*4 + 2  （顶点2）
                        //     tl + i*4 + 3  （顶点3）
                        // 
                        for(int i = 0; i < numFaces; i++)
                        {
                            // 【生成2个三角形】
                            // 
                            // 三角形1：0 → 1 → 2
                            //   索引：tl+i*4, tl+i*4+1, tl+i*4+2
                            // 
                            // 三角形2：0 → 2 → 3
                            //   索引：tl+i*4, tl+i*4+2, tl+i*4+3
                            // 
                            // 【为什么逆时针？】
                            //   Unity使用右手定则：
                            //   - 逆时针 → 法线朝外 → 正面可见
                            //   - 顺时针 → 法线朝内 → 背面被剔除
                            // 
                            // 【可视化】：
                            // 
                            //   从外面看（逆时针）：
                            //   1 ──── 2
                            //   │  ╱  │
                            //   │ ╱   │
                            //   0 ──── 3
                            // 
                            //   三角形1：0→1→2（逆时针，可见）
                            //   三角形2：0→2→3（逆时针，可见）
                            // 
                            tris.AddRange(new int[] { 
                                tl + i * 4,     // 三角形1顶点0
                                tl + i * 4 + 1, // 三角形1顶点1
                                tl + i * 4 + 2, // 三角形1顶点2
                                tl + i * 4,     // 三角形2顶点0（与三角形1共享）
                                tl + i * 4 + 2, // 三角形2顶点2（与三角形1共享）
                                tl + i * 4 + 3  // 三角形2顶点3
                            });
                        }
                    }
                }

        // ========== 【第3步：组装网格】==========
        // 
        // 【将List转换为数组】
        // Unity的Mesh需要数组，不是List
        // ToArray()：将List转换为固定大小的数组
        // 
        // 【数据统计】：
        //   假设一个区块有2,000个可见面：
        //   - 顶点数：2,000 * 4 = 8,000个顶点
        //   - 三角形数：2,000 * 2 = 4,000个三角形
        //   - 索引数：4,000 * 3 = 12,000个索引
        //   - UV坐标：8,000个（每个顶点一个）
        // 
        // 【内存占用估算】：
        //   - Vector3（顶点）：8,000 * 12字节 = 96KB
        //   - int（索引）：12,000 * 4字节 = 48KB
        //   - Vector2（UV）：8,000 * 8字节 = 64KB
        //   - 总计：约208KB（非常小！）
        // 
        mesh.vertices = verts.ToArray();   // 设置顶点数组
        mesh.triangles = tris.ToArray();   // 设置三角形索引
        mesh.uv = uvs.ToArray();           // 设置UV坐标

        // ========== 【第4步：计算法线】==========
        // 
        // 【什么是法线？】
        // 法线（Normal）是垂直于面的向量，用于光照计算
        // 
        // 【为什么需要法线？】
        // - 光照系统需要知道面的朝向
        // - 朝向光源的面更亮，背向光源的面更暗
        // - 创造3D立体感
        // 
        // 【自动计算原理】：
        // Unity会：
        // 1. 计算每个三角形的法线（垂直于三角形平面）
        // 2. 对于共享顶点，平均所有相邻三角形的法线
        // 3. 归一化法线向量（长度为1）
        // 
        // 【示例】：
        //   一个顶点被3个三角形共享
        //   → 计算3个三角形的法线
        //   → 平均这3个法线
        //   → 得到该顶点的法线
        // 
        // 【为什么自动计算？】
        // - 手动计算复杂且容易出错
        // - Unity的算法已经优化过
        // - 对于体素游戏，自动计算足够准确
        mesh.RecalculateNormals();

        // ========== 【第5步：应用网格到组件】==========
        // 
        // 【MeshFilter组件】
        // 作用：存储网格数据，供渲染系统使用
        // 
        // 工作流程：
        //   1. MeshFilter存储Mesh数据
        //   2. 渲染系统读取Mesh数据
        //   3. GPU渲染三角形
        //   4. 屏幕上显示3D模型
        // 
        // 【MeshCollider组件】
        // 作用：使用网格作为碰撞体，用于物理检测
        // 
        // 为什么需要MeshCollider？
        // - 玩家需要与地形碰撞（不能穿墙）
        // - 射线检测需要知道地形形状
        // - 物理系统需要精确的碰撞边界
        // 
        // 【sharedMesh vs mesh】：
        // - mesh：每个对象独立的网格副本
        // - sharedMesh：多个对象共享同一网格数据
        // 
        // 为什么用sharedMesh？
        // - 节省内存：多个区块可以共享网格数据（如果相同）
        // - 但在这个项目中，每个区块网格都不同，所以效果相同
        // 
        // 【应用后会发生什么？】
        // 1. Unity立即更新渲染
        // 2. 玩家可以看到新的地形
        // 3. 物理系统可以检测碰撞
        // 4. 整个过程通常需要几毫秒
        // 
        GetComponent<MeshFilter>().mesh = mesh;        // 渲染网格
        GetComponent<MeshCollider>().sharedMesh = mesh; // 碰撞网格
    }

    /// <summary>
    /// 辅助方法：添加一个方形面（未实现）
    /// 可能是计划中的代码复用优化，但最终采用了内联实现
    /// 保留作为未来重构的参考
    /// </summary>
    void AddSquare(List<Vector3> verts, List<int> tris)
    {
        // 未实现：可以重构上面重复的添加顶点代码
        // 传入：面的方向、位置、纹理类型
        // 输出：添加到verts和tris
    }
}

